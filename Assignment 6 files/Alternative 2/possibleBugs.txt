1) In write operation, if count > strlen(buffer)+1, it can potentially cause a segmentation fault. 
	Possible Solution:
	So, if count is greater than strlen(buffer)+1, then count should be set to strlen(buffer)+1
	
	Aurghya : It is not generally handled in linux systems. That's why write() and read() system calls may cause segmentation faults.
	          Also it is sizeof(buffer) not strlen(buffer) // same for read.


2) 	int *block_addr = (int *)(disk->space + block_size * dip_addr);
	for(int i=p.dip[0]; i<data_size/sizeof(int); i++) {
		int blk = *(block_addr + i);
		bytes_written += write_block_pointers(blk, p.pointer, p.dip[1], buf + bytes_written, count - bytes_written);

		if(bytes_written == count) {
			return bytes_written;
		}

		p.dip[1] = 0;
		p.pointer = 0;
	}

	What if blk is -1 in this code?
	
	Aurghya : corrected at "bug 2 corrected"

3) 	n_entries = block_size/sizeof(int)

		OR

	n_entries = data_size/sizeof(int), NEED TO SET ONE STANDARD IN THE ENTIRE PROGRAM
	
	Aurghya : second one is the correct one. You can set it to this value in the entire program
	          Also make everything in get pointer to data_size. It is a BIG BUG

4) int *block_addr = (int *)(disk->space + block_size*dip_addr);
	for(int i=p.dip[0]; i<data_size/sizeof(int); i++) {
		int blk = *(block_addr + i);

		bytes_read += read_block_pointers(blk, p.pointer, p.dip[1], buf + bytes_read, count - bytes_read);
		if(bytes_read == count) {
			return bytes_read;
		}
	}

	What if blk is -1 in this code as well?
	
	Aurghya : cannot be since reading pointer cannot move after the size of the file. Though it can be done

5) if(curr_inode->file == true || curr_inode->valid == false) return -1;

	-1 is actually true, should return false
	This I changed from -1 to false, because there's no doubt in this.
	
	Aurghya : Fine


6) 	open files vector's size keeps on increasing, instead of always appending at the end of open files vector, it would be a better idea to search for any open file vector element whose inode_n is -1. If not found, then of course, appending is the only option.
	
	Aurghya : This will be an improvement. Can do if you find enough time. The only problem is that the same file descriptor will be used for another file, hence the user needs to be careful. This is the idea behind dup() in linux;
	
7)	
	Is there any reason why're you not resetting the write_pointer in my_close?
	open_files[fd].write_pointer = 0;

	Is it because default mode is append?
	
	Aurghya : IT IS A BUG. The write pointer SHOULD BE LOADED while opening the file. While closing it is not necessary as the file descriptor is not used again in my scheme.
	my_open had some serious issues I have corrected them
