#include <bits/stdc++.h>
#include <iostream>
#include <cstdio>
#include <pthread.h>
#include <cstdlib>
#include <ctime>
#include <signal.h>
#include <unistd.h>
#include <map>

using namespace std;

#define CPS CLOCKS_PER_SEC
#define SLEEP 0
#define RUN 1
#define TERMINATE 2

//numbers to be generated by the producer
#define NUMSGEN 1000

//MAX is maximum buffer size
#define MAX 5000

void* doJobs(void*);
void sleepOrWake(int);

//completed will be 1 when all producer threads have terminated and buffer is empty
int completed = 0;

//N is number of threads
int N;

int allProd = 0;

//vector buffer to store numbers (items)
vector<int> buffer;

//structure to hold context switch details
struct contextSwitch{
	int flag;
	int from;
	int to;
};

//STATUS structure to hold status array (for all thread status) and context switch related details
struct STATUS{
	int* 			status;
	contextSwitch 	change;
	int 			threadTerminated;
};

//S object of structure status
STATUS S;

//class for handling thread functions
class myThreads{

	public:

		pthread_t 	tid;				//thread id
		char 		type;				//thread type 'P' or 'C'
		int 		threadNum;			//thread index in the global array
		int 		state;				//state = 0 means sleep, 1 means awake and 2 means complete
		static map <pthread_t, int> m;	//map to get threadNum from tid

	private:

		//initializing type of thread with 'P' or 'C' each having equal probability
		void initType(){
			if((rand() % 2)==0){
				this->type = 'P';
			}
			else{
				this->type = 'C';
			}

		}

	public:

		//create thread
		void createMe(int index){
			//give thread a type
			this->initType();

			//give it a index, same as received parameter
			this->threadNum = index;

			//initially, the thread will sleep
			this->state = 0;

			//create the thread
			pthread_create(&this->tid, NULL, doJobs, (void *) this);
		}

		void join(){

			//join thread
			pthread_join(this->tid, NULL);
		}
};

myThreads *threadObj;				//threadObj will be a dynamic array of thread objects
map <pthread_t, int> myThreads::m;	//declaring static member map of the above class

//function to install signal handlers
void installSignalHandler(){
	//installing signal handlers here
	signal(SIGUSR1, sleepOrWake);
	signal(SIGUSR2,	sleepOrWake);
}

//the function which handles signals
void sleepOrWake(int signo){

	if(signo==SIGUSR1){
		// cout<<"I am sleeping "<<threadObj[myThreads::m[pthread_self()]].threadNum<<"\n";

		//pthread_self() returns the thread id of the calling thread
		threadObj[myThreads::m[pthread_self()]].state = SLEEP;
		
		//updating STATUS data structure
		S.status[myThreads::m[pthread_self()]] = SLEEP;
	
	}
	else if(signo==SIGUSR2){
		// cout<<"Thanks for waking me up "<<threadObj[myThreads::m[pthread_self()]].threadNum<<"\n";

		//pthread_self() returns the thread id of the calling thread
		threadObj[myThreads::m[pthread_self()]].state = RUN;
		
		//updating STATUS data structure
		S.status[myThreads::m[pthread_self()]] = RUN;
	}

	installSignalHandler();
}

void* doJobs(void *param){

	//casting the received argument into myThreads pointer object	
	myThreads *t;
	t = (myThreads *) param;
	
	//installing signal handler
	installSignalHandler();

	//storing thread index in threadObj array in a local variable named num
	int num = t->threadNum;

	if(threadObj[num].type == 'P'){

		//this is a producer

		int numsGenerate = NUMSGEN;	//how many numbers are to be generated

		//while numbers to be generated are not equal to zero, run this loop
		while(numsGenerate){

			//while the thread is sleeping, run this loop
			while(threadObj[num].state == SLEEP);
			
			//thread is running
			if(buffer.size()==MAX){

				//make the thread to sleep again
				threadObj[num].state = SLEEP;

				//status is sleep
				S.status[num] 		 = SLEEP;
			
			}
			else {

				//buffer is a vector, adding produced number to it
				buffer.push_back(rand()%100);

				//updating numsGenerate var
				numsGenerate--;

				//sleep for sometime, otherwise producer will produce all numbers immediately
				usleep(10000);
			}

		}
	
	}
	else if(threadObj[num].type == 'C'){
		
		//this is a consumer

		//completed will be 1 when all producer threads have terminated and buffer is empty
		while(completed == 0){
			
			if(threadObj[num].state!=SLEEP){

				//thread is running

				if(buffer.size()==0){

					//buffer is empty, cannot consume, so go to sleep
					
					threadObj[num].state = SLEEP;
					S.status[num] = SLEEP;
				
				}
				else {
					
					//consume a product

					buffer.pop_back();
					
					//sleep for sometime, otherwise consumer will consume all items
					usleep(10000);
					
				}
			}
		}
	}


	//producer thread  will terminate if all numbers have been generated
	threadObj[num].state = TERMINATE;

	//update status array
	S.status[num] = TERMINATE;

	S.threadTerminated = num;

	return 0;
}

int SteadyStateReached(){

	if(allProd == 1){
		return 1;
	}

	for(int i=0; i<N; i++){
		if(threadObj[i].type=='P' && threadObj[i].state!=TERMINATE)
			return 0;
	}

	return (buffer.size()==0);
}

void* scheduler(void *param){

	//clock_t start_time;

	int count = 0;

	while(1) {

		usleep(1000);

		count = 0;

		//if thread isn't terminated, then send the waking signal
		if(threadObj[S.change.to].state!=TERMINATE)
			pthread_kill(threadObj[S.change.to].tid, SIGUSR2);

		// start_time = clock();
		// sleep(1);
		// while((clock()-start_time)/CPS < 3 && threadObj[S.change.to].state==1);
		
		//time quantum = 1
		sleep(1);

		//context switch parameter
		S.change.from = S.change.to;

		//get the next non-terminated thread 
		S.change.to = (S.change.to+1)%N;
		while(S.status[S.change.to]==2){
			S.change.to = (S.change.to+1)%N;
			count++;
			if(count==N){
				allProd = 1;
				break;
			}
		}

		//if thread isn't terminated, then send the sleeping signal
		if(threadObj[S.change.from].state!=TERMINATE)
			pthread_kill(threadObj[S.change.from].tid, SIGUSR1);
		
		//context switch happened
		S.change.flag = 1;

		//break if steady state is reached
		if(SteadyStateReached())
			break;

	}

	return 0;
}

void* reporter(void *param){

	while(1){
		while(S.change.flag == 0 && (S.threadTerminated < 0));
		
		if(S.change.flag !=0){
			
			//restoring change flag's value
			S.change.flag = 0;

			//printing buffer size
			cout<<"Number of elements in the buffer : "<<buffer.size()<<'\n';
			
			//printing context switch details
			cout<<"Context Switch from ";

			if(threadObj[S.change.from].type == 'P'){
				cout<<" producer thread with index ";
			}
			else{
				cout<<" consumer thread with index ";
			}

			cout<<S.change.from<<" to ";

			if(threadObj[S.change.to].type == 'P'){
				cout<<" producer thread with index ";
			}
			else{
				cout<<" consumer thread with index ";
			}

			cout<<S.change.to<<" happened \n";
			
			//SteadyStateReached returns true value only when all producers have terminated and buffer is empty
			if(SteadyStateReached()){
				completed = 1;
				cout<<"Process Complete\n";
				break;
			}
		}
		else{

			if(threadObj[S.threadTerminated].type == 'P'){
				cout<<"Producer ";
			}
			else{
				cout<<"Consumer ";
			}

			cout<<"thread with index : "<<S.threadTerminated<<" terminated! \n";
			S.threadTerminated = -1;
		}
	}

	return 0;
}

int main() {
	
	//specifying random seed
	srand((unsigned)time(NULL));

	cout<<"Enter number of threads you want : ";

	//Taking input the value of N from the user
	cin>>N;

	//initializing status change member
	S.change.flag = 0;					//flag is 1 iff context switch happens
	S.change.from = 0;					//context switch from thread index
	S.change.to = 0;					//context switch to thread index
	S.threadTerminated = -1;			//initial value as -1

	//declare N threads
	threadObj = new myThreads[N];

	//create threads
	for(int i=0;i<N;i++){
		threadObj[i].createMe(i);
	}

	//initializing the map from thread id to thread index
	for(int i=0;i<N;i++){
		myThreads::m[threadObj[i].tid]=threadObj[i].threadNum;
	}

	//dynamically create status array of STATUS data structure's object S
	S.status = new int[N];

	//initializing status array to all zeros
	for(int i=0;i<N;i++){
		S.status[i] = 0;
	}

	//thread ids for scheduler and reporter threads
	pthread_t SchId;
	pthread_t RepId;

	//create scheduler thread
	pthread_create(&SchId, NULL, scheduler, NULL);

	//create reporter thread
	pthread_create(&RepId, NULL, reporter, NULL);

	//wait for reporter thread to join main thread
	pthread_join(RepId, NULL);

	//wait for scheduler thread to join main thread
	pthread_join(SchId, NULL);

	//steady state reached
	if(allProd==0)
		cout<<"\nOnly consumer threads are left!\n";
	else
		cout<<"\nNo consumer thread was found! Steady state reached!\n";

	//wait for all threads to join the main thread
	for(int i=0;i<N;i++){
		threadObj[i].join();
	}

	//delete the dynamic array of threadObj
	delete threadObj;

	//delete the dynamic array of status
	delete S.status;

	return 0;
}
