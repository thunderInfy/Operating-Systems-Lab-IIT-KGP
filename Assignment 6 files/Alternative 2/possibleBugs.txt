1) In write operation, if count > strlen(buffer)+1, it can potentially cause a segmentation fault. 
	Possible Solution:
	So, if count is greater than strlen(buffer)+1, then count should be set to strlen(buffer)+1


2) 	int *block_addr = (int *)(disk->space + block_size * dip_addr);
	for(int i=p.dip[0]; i<data_size/sizeof(int); i++) {
		int blk = *(block_addr + i);
		bytes_written += write_block_pointers(blk, p.pointer, p.dip[1], buf + bytes_written, count - bytes_written);

		if(bytes_written == count) {
			return bytes_written;
		}

		p.dip[1] = 0;
		p.pointer = 0;
	}

	What if blk is -1 in this code?

3) 	n_entries = block_size/sizeof(int)

		OR

	n_entries = data_size/sizeof(int), NEED TO SET ONE STANDARD IN THE ENTIRE PROGRAM

4) int *block_addr = (int *)(disk->space + block_size*dip_addr);
	for(int i=p.dip[0]; i<data_size/sizeof(int); i++) {
		int blk = *(block_addr + i);

		bytes_read += read_block_pointers(blk, p.pointer, p.dip[1], buf + bytes_read, count - bytes_read);
		if(bytes_read == count) {
			return bytes_read;
		}
	}

	What if blk is -1 in this code as well?

5) if(curr_inode->file == true || curr_inode->valid == false) return -1;

	-1 is actually true, should return false
	This I changed from -1 to false, because there's no doubt in this.


6) 	open files vector's size keeps on increasing, instead of always appending at the end of open files vector, it would be a better idea to search for any open file vector element whose inode_n is -1. If not found, then of course, appending is the only option.
	
7)	
	Is there any reason why're you not resetting the write_pointer in my_close?
	open_files[fd].write_pointer = 0;

	Is it because default mode is append?